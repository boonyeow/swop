// module swop::swop{
//     use sui::tx_context::{Self, TxContext};
//     use sui::transfer::{Self};
//     use sui::bag::{Self, Bag};
//     use sui::object::{Self, ID, UID};
//     use sui::balance::{Balance};
//     use sui::sui::SUI;
//     use std::option::{Self, Option};
//     use std::vector::{Self};
//     use sui::table::{Self, Table};
//     use sui::coin::{Self, Coin};
//     use sui::clock::{Self, Clock};
//     use swop::vec_set::{Self, VecSet};
//
//     const SWAP_STATUS_PENDING:u64 = 0;
//     const SWAP_STATUS_ACCEPTED:u64 = 1;
//     const SWAP_STATUS_REJECTED:u64 = 2;
//     const SWAP_STATUS_CANCELLED:u64 = 3;
//     const SWAP_STATUS_EXPIRED:u64 = 4;
//
//     const EInsufficientValue:u64 = 0;
//     const EInvalidExpiry: u64 = 1;
//     const EInvalidSwapId: u64 = 2;
//     const ENotInitiator: u64 = 3;
//     const ENotCounterparty: u64 = 4;
//     const EActionNotAllowed: u64 = 5;
//     const ESuppliedLengthMismatch: u64 = 6;
//     const EUnexpectedObjectFound: u64 = 7;
//     const ERequestExpired: u64 = 8;
//
//     struct SwapDB has key, store{
//         id: UID,
//         registry: Bag,
//         requests: Table<address,VecSet<ID>>
//     }
//
//     struct SwapRequest has key, store{
//         id: UID,
//         initiator: address,
//         counterparty: address,
//         nfts_to_receive: VecSet<ID>,
//         coins_to_receive: u64,
//         initiator_offer: Option<Offer>,
//         counterparty_offer: Option<Offer>,
//         status: u64,
//         expiry: u64,
//     }
//
//     struct Offer has store{
//         escrowed_nfts: Bag,
//         escrowed_balance: Balance<SUI>,
//     }
//
//     fun init(ctx: &mut TxContext){
//         transfer::share_object(SwapDB{
//             id: object::new(ctx),
//             registry: bag::new(ctx),
//             requests: table::new<address, VecSet<ID>>(ctx)
//         })
//     }
//
//     public entry fun create<T1: key+store, T2: key+store, T3: key+store>(
//         swap_db: &mut SwapDB,
//         slot_t1: vector<T1>,
//         slot_t2: vector<T2>,
//         slot_t3: vector<T3>,
//         counterparty: address,
//         nfts_to_receive: vector<ID>,
//         coins_to_receive: u64,
//         escrowed_coins: Coin<SUI>,
//         clock: &Clock,
//         expiry: u64,
//         ctx: &mut TxContext){
//         assert!(expiry > clock::timestamp_ms(clock), EInvalidExpiry);
//         assert!(
//             vector::length(&slot_t1) <= 1 &&
//                 vector::length(&slot_t2) <= 1 &&
//                 vector::length(&slot_t3) <= 1,
//             ESuppliedLengthMismatch
//         );
//
//         let initiator = tx_context::sender(ctx);
//         let swap = SwapRequest{
//             id: object::new(ctx),
//             initiator,
//             counterparty,
//             nfts_to_receive:  vec_set::from_vector(nfts_to_receive),
//             coins_to_receive,
//             initiator_offer: option::some(
//                 new_offer(
//                     slot_t1, slot_t2, slot_t3, escrowed_coins, ctx
//                 )
//             ),
//             counterparty_offer: option::none(),
//             status: SWAP_STATUS_PENDING,
//             expiry
//         };
//
//         let swap_id = object::id(&swap);
//
//         // update registry
//         bag::add(&mut swap_db.registry, swap_id, swap);
//
//         // update requests
//         if(table::contains(&swap_db.requests, initiator)){
//             let open_swaps = table::borrow_mut(&mut swap_db.requests, initiator);
//             vec_set::insert(open_swaps, swap_id);
//         } else {
//             table::add(&mut swap_db.requests, initiator, vec_set::singleton(swap_id));
//         };
//     }
//
//     fun new_offer<T1: key+store, T2: key+store, T3:key+store>(slot_t1: vector<T1>, slot_t2: vector<T2>, slot_t3: vector<T3>, escrowed_coins: Coin<SUI>, ctx: &mut TxContext): Offer{
//         let escrowed_nfts = bag::new(ctx);
//         let count:u8 = 0;
//
//         if(!vector::is_empty(&slot_t1)){
//             bag::add(&mut escrowed_nfts, count, vector::pop_back(&mut slot_t1));
//             count = count + 1;
//         };
//
//         if(!vector::is_empty(&slot_t2)){
//             bag::add(&mut escrowed_nfts, count, vector::pop_back(&mut slot_t2));
//             count = count + 1;
//         };
//
//         if(!vector::is_empty(&slot_t3)){
//             bag::add(&mut escrowed_nfts, count, vector::pop_back(&mut slot_t3));
//         };
//
//         vector::destroy_empty(slot_t1);
//         vector::destroy_empty(slot_t2);
//         vector::destroy_empty(slot_t3);
//
//
//         Offer{
//             escrowed_nfts,
//             escrowed_balance: coin::into_balance(escrowed_coins)
//         }
//     }
//
//     public entry fun cancel<T: key+store>(swap_db: &mut SwapDB, swap_id: ID, ctx: &mut TxContext){
//         let registry = &mut swap_db.registry;
//         assert!(bag::contains(registry, swap_id), EInvalidSwapId);
//         let sender = tx_context::sender(ctx);
//         let swap: &SwapRequest = bag::borrow(registry, swap_id);
//         assert!(swap.initiator == sender, ENotInitiator);
//         assert!(swap.status == SWAP_STATUS_PENDING, EActionNotAllowed);
//
//         // unpack swap request
//         let SwapRequest{
//             id,
//             initiator: _,
//             counterparty:_,
//             nfts_to_receive:_,
//             coins_to_receive:_,
//             initiator_offer,
//             counterparty_offer,
//             status:_,
//             expiry:_
//         } = bag::remove(registry, swap_id);
//
//         // cleanup
//         object::delete(id);
//         option::destroy_none(counterparty_offer); // option for initiator_offer should always be none
//
//         // unpack and transfer back to initiator
//         // option for initiator should always have something
//         let Offer { escrowed_nfts, escrowed_balance} = option::destroy_some(initiator_offer);
//         let count = 0;
//         while(!bag::is_empty(&escrowed_nfts)){
//             transfer::public_transfer(
//                 bag::remove<u8, T>(&mut escrowed_nfts, count),
//                 sender
//             );
//             count = count + 1;
//         };
//         bag::destroy_empty(escrowed_nfts);
//
//         transfer::public_transfer(coin::from_balance(escrowed_balance, ctx),sender);
//
//         let requests = &mut swap_db.requests;
//         let open_swaps = table::borrow_mut(requests, sender);
//         vec_set::remove(open_swaps, &swap_id);
//         if(vec_set::is_empty(open_swaps)){
//             table::remove(requests, sender);
//         }
//     }
//
//     public entry fun reject(swap_db: &mut SwapDB, swap_id: ID, ctx: &mut TxContext){
//         let registry = &mut swap_db.registry;
//         let requests = &mut swap_db.requests;
//         assert!(bag::contains(registry, swap_id), EInvalidSwapId);
//         let sender = tx_context::sender(ctx);
//         let swap_mut: &mut SwapRequest = bag::borrow_mut(registry, swap_id);
//
//         assert!(swap_mut.counterparty == sender, ENotCounterparty);
//         assert!(swap_mut.status == SWAP_STATUS_PENDING, EActionNotAllowed);
//         swap_mut.status = SWAP_STATUS_REJECTED;
//
//         // update requests
//         let open_swaps = table::borrow_mut(requests, swap_mut.initiator);
//         vec_set::remove(open_swaps, &swap_id);
//     }
//
//     public entry fun accept<T1: key+store, T2: key+store, T3: key+store, G: key+store>(
//         swap_db: &mut SwapDB,
//         swap_id: ID,
//         clock: &Clock,
//         slot_t1: vector<T1>,
//         slot_t2: vector<T2>,
//         slot_t3: vector<T3>,
//         escrowed_coins: Coin<SUI>,
//         ctx: &mut TxContext){
//         assert!(
//             vector::length(&slot_t1) <= 1 &&
//             vector::length(&slot_t2) <= 1 &&
//             vector::length(&slot_t3) <= 1,
//             ESuppliedLengthMismatch
//         );
//
//         let registry = &mut swap_db.registry;
//         assert!(bag::contains(registry, swap_id), EInvalidSwapId);
//
//         let sender = tx_context::sender(ctx);
//         let swap_mut: &mut SwapRequest = bag::borrow_mut(registry, swap_id);
//         assert!(swap_mut.counterparty == sender, ENotCounterparty);
//         assert!(clock::timestamp_ms(clock) < swap_mut.expiry, ERequestExpired);
//         assert!(swap_mut.coins_to_receive == coin::value(&escrowed_coins), EInsufficientValue);
//
//         assert!(validate_swap_conditions(&swap_mut.nfts_to_receive, swap_mut.coins_to_receive, slot_t1, slot_t2, slot_t3, &escrowed_coins), EUnexpectedObjectFound);
//         // make sure royalty is paid when users send the coins
//         // min coin::value for users to call accept function is 1 i.e. 1 sui to execute tx
//         // to implement a shared object to enable dynamic royalties (i.e. peg it to offchain data for sui-usdt conversion)
//
//
//         // update counterparty offer
//         option::fill(&mut swap_mut.counterparty_offer,
//             new_offer(
//                 slot_t1, slot_t2, slot_t3, escrowed_coins, ctx
//             )
//         );
//
//         let initiator_offer = option::extract(&mut swap_mut.initiator_offer);
//         let count = 0;
//         while(!bag::is_empty(&initiator_offer.escrowed_nfts)){
//             // bag::remove<ID, G>()
//             transfer::public_transfer(
//                 bag::remove(
//                     &mut initiator_offer.escrowed_nfts,
//                     count
//                 ),
//                 swap_mut.initiator
//             );
//             count = count + 1;
//         };
//         // withdraw initiator offer
//
//
//
//         if(!vector::is_empty(&slot_t1)){
//             let temp  = vector::pop_back(&mut slot_t1);
//             assert!(vec_set::contains(&swap_mut.nfts_to_receive, &object::id(&temp)), EUnexpectedObjectFound);
//             // add to escrowed_nfts bag
//             // initiator's offer can be withdrawn
//             // when you accept force them to pay
//             // when initiator claims, then force them to pay
//
//         };
//     }
//
//     fun add_to_escrowed_bag<T: key+store>(slot: vector<T>, escrowed_nfts: &mut Bag){
//
//     }
//
//     fun validate_swap_conditions<T1: key+store, T2: key+store, T3: key+store>(nfts_to_receive: &VecSet<ID>, coins_to_receive: u64, slot_t1: vector<T1>, slot_t2: vector<T2>, slot_t3: vector<T3>, escrowed_coins_ref: &Coin<SUI>): bool{
//         let received_exact_amount = (coins_to_receive == coin::value(escrowed_coins_ref));
//
//         (
//             is_exist(slot_t1, nfts_to_receive) &&
//             is_exist(slot_t2, nfts_to_receive) &&
//             is_exist(slot_t3, nfts_to_receive) &&
//             received_exact_amount
//         )
//     }
//
//     fun is_exist<T: key+store>(slot: vector<T>, nfts_to_receive: &VecSet<ID>) : bool{
//         if(vector::is_empty(&slot)){
//             return false
//         };
//
//         let temp = vector::pop_back(&mut slot);
//         let id = object::id(&temp);
//         if(!vec_set::contains(nfts_to_receive, &id)){
//             return false;
//         };
//
//         true
//     }
// }